
* Prototype Pattern 이란?
- 클래스로부터 인스턴스를 생성하는 것이 아니라 인스턴스로부터 별도의 인스턴스를 만드는 패턴.
  
- 인스턴스를 복사해서 새로운 인스턴스를 만드는 경우

  (1). 종류가 너무 많아 클래스로 정리되지 않는 경우  
     : 예제 프로그램에서 3개의 모형이 등장했다.
       마음먹기에 따라 얼마든지 많은 종류의 모형을 만들 수 있다. 
       그러나 이것을 모두 각각의 클래스로 만들면 클래스의 수가
       너무 많아지기 때문에 소스코드를 관리하기 어렵다.
       
  (2). 클래스로부터 인스턴스 생성이 어려운 경우
     : 사용자가 조작을 해서 만든 도형을 나타내는 인스턴스를 만들고자 할 때,
       이 때 클래스를 사용하는 것이 아니라 인스턴스를 복사해서 만든다.
       
  (3). framework와 생성하는 인스턴스를 분리하고 싶은 경우
     : 예제 프로그램에서 인스턴스의 복사(clone)를 실행하는 부분을 framework 패키지
       안에 설정.
       Manager 클래스의 create 메소드에는 클래스 이름 대신 'strong message' 나 'slash box'라는
       문자열을 인스턴스 생성을 위한 이름으로 제공한다. 이는 인스턴스 생성 기구인 new 라는 형식을
       보다 넓게 이용해서 클래스 이름의 속박으로부터 framework를 분리할 수 있다.     

- 소스 내부에 클래스의 이름을 쓰는 것이 항상 나쁜 것만은 아니다.
  그러나, 소스 내부에 이용할 클래스의 이름이 쓰여있으면 그 클래스와 분리해서 재이용할 수 없게된다.
  
  물론 소스를 고쳐서 클래스 이름을 변경할 수 있다. 하지만 여기서 기술하는 
  '부품으로써 재이용'에서 소스를 고칠 수 있는지는 중요하지 않다.
  비록 클래스 파일(.class)만 가지고 있더래도 그 클래스를 재이용할 수 있는지가 중요하다.
  다시 말해 소스 파일(.java)이 없어도 재사용할 수 있는지가 포인트이다.
  즉, 긴밀히 결합해야 할 클래스 이름이 소스 안에 사용 되는 것은 문제가 되지 않지만,
      부품으로 독립시켜야 하는 이름이 소스 안에 사용되는 것은 문제가 된다.

* Prototype Pattern의 등장인물
  
  - Prototype(원형)의 역할
      인스턴스를 복사하여 새로운 인스턴스를 만들기 위한 메소드를 결정.
      (Product 인터페이스가 이 역할)
      
  - ConcretePrototype(구체적인 원형)의 역할
      인스턴스를 복사해서 새로운 인스턴스를 만드는 메소드를 실제로 구현
      (MessageBox 클래스나 UnderlinePen 클래스가 이 역할)
      
  - Client(이용자)의 역할
      인스턴스를 복사하는 메소드를 이용해서 새로운 인스턴스를 만든다.
      (Manager 클래스가 이 역할)