
 * Bridge Pattern 이란?
 - '기능의 클래스 계층'과 '구현의 클래스 계층' 사이를 연결하는 역할
 - 1) '기능'의 클래스 계층
      새로운 기능을 추가하고 싶을 경우 클래스 계층 안에서 자신의 목적과
      가까운 클래스를 찾아내 그 하위 클래스를 만들어, 목적한 기능을 추가한
      새로운 클래스를 만든다는 것.
 - 2) '구현'의 클래스 계층
      상위 클래스(일련의 메소드들을 추상 메소드로서 선언하고 인터페이스(API)를 규정)와 
      하위 클래스(추상 메소드를 실제로 구현)의 역할 분담에 의해 부품으로서의 가치(교환가능성)이 높아짐.
      
 * Bridge Pattern 의 등장인물
 - Abstraction(추상화) 의 역할
    '기능의 클래스 계층'의 최상위 클래스.  
    Implementor 역할의 메소드를 사용해서 기본적인 기능만이 기술되어 있는 클래스.
    이 인스턴스는 Implementor 역할을 가지고 있다.
    (Display 클래스가 이 역할)
 
  - RefinedAbstraction(개선된 추상화) 의 역할
    Abstraction 역할에 대해 기능을 추가한 역할.
    (CountDisplay 클래스가 이 역할)
    
  - Implementor(구현자) 의 역할
      '구현의 클래스 계층'의 최상위 클래스.
      Abstraction 역할의 인터페이스(API)를 구현하기 위한 메소드를 규정하는 역할.
      (DisplayImpl 클래스가 이 역할)
      
  - ConcreteImplementor(구체적인 구현자) 의 역할
      Implementor 역할의 인터페이스(API)를 구체적으로 구현하는 역할.
      (StringDisplayImpl 클래스가 이 역할)
      
      
 * Bridge Pattern 의 특징
  - 이 패턴은 '기능의 클래스 계층'과 '구현의 클래스 계층' 을 분리하는 것.
    => 각각의 클래스 계층을 독립적으로 확장할 수 있다.
       기능을 추가하고 싶으면 기능의 클래스 계층에 클래스를 추가.(새로 추가한 기능은 '모든 구현'에서 이용 가능)
   ex) 구현의 클래스 계층을 OS에 적용해 보자
     ==> 윈도우판, 맥킨토시판, 유닉스판으로 분리되는 프로그램이 있다고 할 때,
         각 운영체제 공통의 인터페이스(API)를 정해서 Implementor 역할로 하고 
         ConcreteImplementor 역할로 윈도우판, 맥킨토시판, 유닉스판의 세개의 클래스를 만든다.
         이렇게 하면, '기능의 클래스 계층' 쪽에 아무리 기능을 추가한다해도 세 개의 OS에 동시에 대응할 수 있다.
         
         
  - '상속'은 클래스를 확장하기 편리하지만 클래스간의 연결을 강하게 고정시킨다.
     즉, 소스 코드를 고쳐 쓰지 않는 한 바꿀 수 없는 매우 견고한 연결이 된다.
     
     프로그램의 필요에 따라 클래스 간의 관계를 척척 바꾸고 싶을 때 상속보다는 '위임'을 사용.
     Display 클래스 내에서 위임이 사용된다. 
     Display 클래스의 impl 필드에서는 구현되는 인스턴스가 저장되어 있어
      => open 실행 시 impl.rawOpen()을 호출
      => print 실행 시 impl.rawPrint()을 호출
      => close 실행 시 impl.rawClose()을 호출
      라는 식으로 '떠넘기기'를 한다 ( ===> 위임)
      Display 클래스의 인스턴스를 만드는 단계에서 인수로 전달되어 온 것과 연결되기 때문.
      (Main 클래스 내에서 Display나 CountDisplay의 인스턴스를 만들고 그 때 StringDisplayImpl 인스턴스를 인수로 전달)
      
      만약, StringDisplayImpl 클래스이외의 ConcreteImplementor 역할이 있다고 가정하고
            그 인스턴스를 Display나 CountDisplay에게 전달하면 그것으로 구현이 확실히 교체된다.
            이 교체를 수행할 때 수정한 것은 Main 클래스 뿐.
            
            
            
            
            