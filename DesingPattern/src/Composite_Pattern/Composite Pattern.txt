
 * Composite Pattern 이란?
 - 그릇과 내용물을 동일시하고 재귀적인 구조를 형성하는 패턴.
  
   클라이언트는 Component 인터페이스/추상클래스를 이용해서 개별/복합객체를 사용할 수 있다.
   객체(Leaf)와 복합객체(Composite)는 Component를 상속받으며 해당 메소드 중 연관된 메소드만 재정의한다. 
   객체는 실제 사용되는 말단 객체이며 복합객체는 하단에 또다른 객체의 집합을 구성하는 상위객체이다.
   그러나 객체나 복합객체나 이를 관리하는 부분에서는 동일하게 취급한다.

   컴퓨터 파일의 디렉터리를 생각해보자.
   디렉터리와 파일은 서로 다르지만 모두 '디렉터리 안에 넣을 수 있는 것'이다.
   이렇게 디렉터리와 파일을 합해서 '디렉터리 엔트리'라고 부른다.
   디렉터리 엔트리라는 이름으로 디렉터리와 파일을 같은 종류로 간주하고 있다.
   
   디렉터리와 파일을 모아서 디렉터리 엔트리로 취급하듯이 그릇과 내용물을 같은
   종류로 취급하면 편리한 경우가 있다.
   'Composite Pattern'이란 그릇과 내용물을 동일시해서 재귀적인 구조를 만들기 위한 패턴.
   
   파일 시스템과 HTML의 리스트(ul요소, ol요소, dl요소)와 테이블에서 Composite Pattern으로 표현 가능.
   
   
 * Composite Pattern 의 등장인물
 
  - Leaf(나뭇잎)의 역할
      Leaf는 '내용물'을 표시하는 역할, 내부에는 다른 것을 넣을 수 없다.
      (File 클래스가 이 역할)
      
  - Composite(복합체)의 역할
      Composite는 '그릇'을 나타내는 역할, Leaf 역할이나 Composite 역할을 넣을 수 있다.
      (Directory 클래스가 이 역할)
      
  - Component의 역할
      Leaf 역할과 Composite 역할을 동일시 하는 역할.
      Component는 Leaf 역할과 Composite 역할에 공통적인 상위 클래스로 실현.
      (Entry 클래스가 이 역할)
      
  - Client(의뢰자)의 역할
      Composite 패턴의 사용자.
      (Main 클래스가 이 역할)
      
   Composite 역할이 포함하고 있는 Component 역할(즉, Leaf 역할이나 Composite 역할)을
   부모에 대한 '자식'으로 간주. 즉, getChild 메소드는 Component 역할로부터 '자식'을 얻기 위한 메소드
   
   
   
 * Composite Pattern 의 특징
 
 ==> Composite Pattern은 그릇과 내용물을 동일시하는 패턴이지만, 복수와 단수 역시 동일시 한다.
     즉, 여러 개를 모아서 마치 하나인 것처럼 취급하는 것이다.
        (예를 들면 프로그램의 동작테스트를 생각할 때 키보드 입력테스트, 파일 입력테스트, 네트워크 입력테스트
                   이 세개를 합해 '입력 테스트'로 하고 싶을 때 Composite 패턴을 사용.  )
                   
 ==> 예제 프로그램에서 Entry 클래스에서 add 메소드를 정의하고 예외를 제공.
     그러나, add 메소드를 실제로 사용할 수 있는 것은 Directory 클래스 뿐이다.    
     
     **add 구현 방법**
     1) Entry 클래스에서 구현하고 에러로 처리
        예제 프로그램에서 이렇게 사용. add 메소드를 실제로 사용할 수 있는 Directory 클래스에서는
        Entry 클래스의 add를 오버라이드해서 의미있는 구현으로 바꾸었다.
        File 클래스는 Entry 클래스에서 add 메소드를 상속하고 있기 때문에 add는 가능하지만 예외 제공.
     2) Entry 클래스에서 구현하고 아무것도 실행하지 않음
        구현하지만 에러로 처리하지 않는(아무것도 실행하지 않는) 방법
     3) Entry 클래스에서 선언을 하지만 구현은 하지 않음
        add 메소드를 Entry 클래스에서는 추상 메소드를 하고, 하위 클래스에서는 필요하면 정의하고
        필요하지 않으면 에러로 처리. 
        일관성을 가질 수 있고 불필요한 경우의 작동을 하위 클래스에서 결정 가능한 장점.
        그러나 원래 필요 없는 add(경우에 따라서는 remove나 getChild 등)를 File 쪽에서 정의해야 하는 단점
     4) Directory 클래스에만 넣는다
        이 방법은 Entry 형의 변수(실제의 내용은 Directory의 인스턴스)에 add할 때, 하나하나 Directory 형으로
        캐스트 해야하는 불편함  
